import numpy as np
import pandas as pd
from mask_functions import rle2mask
from glob import glob
from tqdm import tqdm
import os
import pydicom
from multiprocessing import Pool
import random
from shutil import copyfile

def _make_dir(dir_name):
    if not os.path.exists(dir_name):
        os.makedirs(dir_name)


def make_fold(data_path='/data/pneumo/train/', 
                 fold=5,
                 save_path='/data/pneumo/fold/',
                 seed=1,
                 exclude_ids=[], #see https://www.kaggle.com/c/siim-acr-pneumothorax-segmentation/discussion/98478#latest-572385
                 stratified=True,
                 cpu_num=16):
    
    '''
    make *fold bins
    data_path: the datapath should have img and mask numpy which generated by run_save_train()
               and meta.csv
    fold: folder number
    seed: random seed
    exclude_ids: a list of image id (dicom file name) to be excluded
    stratified: set True to make stratified fold based on class number (0/1)
    '''

    _make_dir(save_path)
    meta_df = pd.read_csv(data_path + 'meta.csv')
    for i in range(1, fold+1):
        # make all fold folders 1~fold
        _make_dir(save_path + '/' + str(int(i)))


    if stratified:
        meta_df = meta_df.sort_values('class')

    random.seed(seed)

    j = 0
    # initialize fold column
    meta_df['fold'] = np.nan
    fold_nums = [int(x) for x in range(1, fold+1)]
    for i, row in meta_df.iterrows():
        image_id = row['image_id']
        if image_id in exclude_ids:
            next

        if j == 0:
            random.shuffle(fold_nums)

        meta_df.loc[i, 'fold'] = str(fold_nums[j])

        if j == fold-1:
            j = 0
        else:
            j +=1


    # copy files with multiprocessing
    p = Pool(processes=cpu_num)
    job_args = [(row['path'], row['image_id'], row['fold'], save_path) for i, row in meta_df.iterrows()]
    list(tqdm(p.imap(_wrap_copy_numpy, job_args), total=len(meta_df)))

    # save meta file with fold column
    meta_df.to_csv(save_path + '/meta.csv', index=False)


def _wrap_copy_numpy(args):
    return _copy_numpy(*args)

def _copy_numpy(source_path, image_id, fold, save_base_path):

    save_path = save_base_path + '/' + fold + '/' + image_id + '.npy'

    copyfile(source_path, save_path)



def run_save_train(dcm_base_path='/data/pneumo/dicom-images-train/',
                   mask_csv_path='/data/pneumo/train-rle.csv',
                   save_path='/data/pneumo/train/',
                   cpu_num=16):
    '''
    run save train image and their masks in save_path as numpy array. Note: mask will be 0-1

        dcm_base_path: path that has all dicom data from GCP (original data)
        mask_csv_path: csv file path
        save_path : save path
        cpu_num : the number of cpu for multiprocessing

    '''
    
    _make_dir(save_path)
    mask_csv = pd.read_csv(mask_csv_path)
    dcm_path_list = glob(dcm_base_path+'*/*/*.dcm')

    p = Pool(processes=cpu_num)
    job_args = [_get_job_args(dcm_path, mask_csv, save_path) for dcm_path in dcm_path_list]
    meta_list = list(tqdm(p.imap(_wrap_save_img_mask, job_args), total=len(dcm_path_list)))

    meta_df = pd.DataFrame(meta_list)
    meta_df.to_csv(save_path + '/meta.csv', index=False)

def _get_job_args(dcm_path, mask_csv, save_base_path):
    '''
    return (dcm_path, rle list, save path) from mask_csv based on dcm_path.
    This function is supposed to be called with in map multiprocessing as job args
    '''
    image_id = dcm_path.split('/')[-1].split('.dcm')[0]
    rle_list = mask_csv[mask_csv['ImageId'] == image_id][' EncodedPixels'].values
    return dcm_path, rle_list, save_base_path + image_id


def _wrap_save_img_mask(args):
    return _save_img_mask(*args)

def _save_img_mask(dcm_path, rle_list, save_path):
    '''
    it's supposed to be called with multiprocessing.
    save dicom and its mask to save_path as numpy array, and it returns meta data as dictionary
    save_path should be base + image_id
    '''
    
    # for path in tqdm(dcm_path_list[:10]):
    dataset = pydicom.dcmread(dcm_path)

    img = dataset.pixel_array

    meta = {
        'path' : save_path + '.npy',
        'image_id': save_path.split('/')[-1].split('.dcm')[0],
        'storage_type': dataset.SOPClassUID,
        'name' : dataset.PatientName,
        'id' : dataset.PatientID,
        'age' : dataset.PatientAge,
        'sex' : dataset.PatientSex,
        'modality' : dataset.Modality,
        'body_part' : dataset.BodyPartExamined,
        'view' : dataset.ViewPosition,
        'height' : img.shape[0],
        'width' : img.shape[1],
        'pixel_spacing' : dataset.PixelSpacing
    }


    for i, rle in enumerate(rle_list):

        if rle == ' -1':
            # negative case
            mask = np.zeros(img.shape)
            meta['class'] = 0
        else:
            meta['class'] = 1
            if i == 0:
                mask = rle2mask(rle, img.shape[1], img.shape[0]).T
            else:
                mask2 = rle2mask(rle, img.shape[1], img.shape[0]).T
                mask = np.add(mask, mask2)

    # originally, mask is 0 and 255. change the values to 0 and 1
    mask[mask == 255] = 1
    mask = np.array(mask, dtype=np.uint8)

    np.save(save_path,{'img':img, 'mask':mask})
    return meta

